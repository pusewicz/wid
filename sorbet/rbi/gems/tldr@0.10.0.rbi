# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `tldr` gem.
# Please instead update this file by running `bin/tapioca gem tldr`.


# source://tldr//lib/tldr/reporters/icon_provider.rb#1
module IconProvider; end

# source://tldr//lib/tldr/reporters/icon_provider.rb#2
class IconProvider::Base
  # source://tldr//lib/tldr/reporters/icon_provider.rb#39
  def alarm; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#11
  def error; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#7
  def failure; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#35
  def not_run; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#43
  def rock_on; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#23
  def run; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#47
  def seed; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#15
  def skip; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#31
  def slow; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#3
  def success; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#19
  def tldr; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#27
  def wip; end
end

# source://tldr//lib/tldr/reporters/icon_provider.rb#52
class IconProvider::Emoji < ::IconProvider::Base
  # source://tldr//lib/tldr/reporters/icon_provider.rb#89
  def alarm; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#61
  def error; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#57
  def failure; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#85
  def not_run; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#93
  def rock_on; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#73
  def run; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#97
  def seed; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#65
  def skip; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#81
  def slow; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#53
  def success; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#69
  def tldr; end

  # source://tldr//lib/tldr/reporters/icon_provider.rb#77
  def wip; end
end

# source://tldr//lib/tldr/argv_parser.rb#3
class TLDR
  include ::TLDR::Assertions
  include ::TLDR::Skippable
  include ::TLDR::Hooks

  class << self
    # source://tldr//lib/tldr/parallel_controls.rb#44
    def dont_run_these_in_parallel!(klass_method_tuples = T.unsafe(nil)); end

    # source://tldr//lib/tldr/backtrace_filter.rb#37
    def filter_backtrace(backtrace); end

    # source://tldr//lib/tldr/parallel_controls.rb#18
    def run_these_together!(klass_method_tuples = T.unsafe(nil)); end
  end
end

# source://tldr//lib/tldr/argv_parser.rb#4
class TLDR::ArgvParser
  # source://tldr//lib/tldr/argv_parser.rb#7
  def parse(args, options = T.unsafe(nil)); end
end

# source://tldr//lib/tldr/argv_parser.rb#5
TLDR::ArgvParser::PATTERN_FRIENDLY_SPLITTER = T.let(T.unsafe(nil), Regexp)

# source://tldr//lib/tldr/assertions/minitest_compatibility.rb#17
module TLDR::Assertions
  # source://tldr//lib/tldr/assertions.rb#45
  def assert(bool, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#61
  def assert_empty(obj, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#76
  def assert_equal(expected, actual, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#88
  def assert_in_delta(expected, actual, delta = T.unsafe(nil), message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#104
  def assert_in_epsilon(expected, actual, epsilon = T.unsafe(nil), message = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://tldr//lib/tldr/assertions.rb#112
  def assert_include?(expected, actual, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#128
  def assert_instance_of(expected, actual, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#142
  def assert_kind_of(expected, actual, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#156
  def assert_match(matcher, actual, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#174
  def assert_nil(obj, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#190
  def assert_operator(left_operand, operator, right_operand, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#204
  def assert_output(expected_stdout, expected_stderr, message = T.unsafe(nil), &block); end

  # source://tldr//lib/tldr/assertions.rb#222
  def assert_path_exists(path, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#238
  def assert_pattern(message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#258
  def assert_predicate(obj, method, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#274
  def assert_raises(*exp); end

  # source://tldr//lib/tldr/assertions.rb#306
  def assert_respond_to(obj, method, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#322
  def assert_same(expected, actual, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#340
  def assert_silent; end

  # source://tldr//lib/tldr/assertions.rb#346
  def assert_throws(expected, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#56
  def refute(test, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#70
  def refute_empty(obj, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#81
  def refute_equal(expected, actual, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#96
  def refute_in_delta(expected, actual, delta = T.unsafe(nil), message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#108
  def refute_in_epsilon(expected, actual, epsilon = T.unsafe(nil), msg = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://tldr//lib/tldr/assertions.rb#120
  def refute_include?(expected, actual, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#135
  def refute_instance_of(expected, actual, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#149
  def refute_kind_of(expected, actual, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#166
  def refute_match(matcher, actual, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#182
  def refute_nil(obj, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#197
  def refute_operator(left_operand, operator, right_operand, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#230
  def refute_path_exists(path, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#248
  def refute_pattern(message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#266
  def refute_predicate(obj, method, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#314
  def refute_respond_to(obj, method, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions.rb#333
  def refute_same(expected, actual, message = T.unsafe(nil)); end

  class << self
    # source://tldr//lib/tldr/assertions.rb#31
    def capture_io; end

    # source://tldr//lib/tldr/assertions.rb#27
    def diff(expected, actual); end

    # source://tldr//lib/tldr/assertions.rb#16
    def h(obj); end

    # source://tldr//lib/tldr/assertions.rb#20
    def msg(message = T.unsafe(nil), &default); end
  end
end

# source://tldr//lib/tldr/assertions/minitest_compatibility.rb#18
module TLDR::Assertions::MinitestCompatibility
  # source://tldr//lib/tldr/assertions/minitest_compatibility.rb#19
  def assert_includes(actual, expected, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions/minitest_compatibility.rb#27
  def assert_send(receiver_method_args, message = T.unsafe(nil)); end

  # source://tldr//lib/tldr/assertions/minitest_compatibility.rb#37
  def capture_io(&blk); end

  # source://tldr//lib/tldr/assertions/minitest_compatibility.rb#41
  def mu_pp(obj); end

  # source://tldr//lib/tldr/assertions/minitest_compatibility.rb#23
  def refute_includes(actual, expected, message = T.unsafe(nil)); end
end

# source://tldr//lib/tldr/backtrace_filter.rb#2
class TLDR::BacktraceFilter
  # source://tldr//lib/tldr/backtrace_filter.rb#5
  def filter(backtrace); end

  private

  # @return [Boolean]
  #
  # source://tldr//lib/tldr/backtrace_filter.rb#32
  def internal?(frame); end

  # @return [Boolean]
  #
  # source://tldr//lib/tldr/backtrace_filter.rb#28
  def meaningful?(frame); end

  # source://tldr//lib/tldr/backtrace_filter.rb#22
  def trim_internal_frames(backtrace); end

  # source://tldr//lib/tldr/backtrace_filter.rb#16
  def trim_leading_frames(backtrace); end
end

# source://tldr//lib/tldr/backtrace_filter.rb#3
TLDR::BacktraceFilter::BASE_PATH = T.let(T.unsafe(nil), String)

# source://tldr//lib/tldr/value/config.rb#29
TLDR::CONFIG_ATTRIBUTES = T.let(T.unsafe(nil), Array)

# source://tldr//lib/tldr/value/config.rb#2
TLDR::CONFLAGS = T.let(T.unsafe(nil), Hash)

# source://tldr//lib/tldr/class_util.rb#2
module TLDR::ClassUtil
  class << self
    # source://tldr//lib/tldr/class_util.rb#3
    def gather_descendants(root_klass); end

    # source://tldr//lib/tldr/class_util.rb#9
    def gather_tests(klass); end
  end
end

# source://tldr//lib/tldr/value/config.rb#38
class TLDR::Config < ::Struct
  # @return [Config] a new instance of Config
  #
  # source://tldr//lib/tldr/value/config.rb#39
  def initialize(**args); end

  def base_path; end
  def cli_defaults; end
  def config_intended_for_merge_only; end
  def exclude_names; end
  def exclude_names=(_); end
  def exclude_paths; end
  def exclude_paths=(_); end
  def fail_fast; end
  def fail_fast=(_); end
  def helper_paths; end
  def helper_paths=(_); end
  def i_am_being_watched; end
  def i_am_being_watched=(_); end
  def load_paths; end
  def load_paths=(_); end

  # source://tldr//lib/tldr/value/config.rb#126
  def merge(other); end

  # source://tldr//lib/tldr/value/config.rb#104
  def merge_defaults(user_args); end

  def names; end
  def names=(_); end
  def no_dotfile; end
  def no_emoji; end
  def no_emoji=(_); end
  def no_helper; end
  def no_helper=(_); end
  def no_prepend; end
  def no_prepend=(_); end
  def parallel; end
  def parallel=(_); end
  def paths; end
  def paths=(_); end
  def prepend_paths; end
  def prepend_paths=(_); end
  def print_interrupted_test_backtraces; end
  def print_interrupted_test_backtraces=(_); end
  def reporter; end
  def reporter=(_); end
  def seed; end
  def seed=(_); end
  def seed_set_intentionally; end

  # source://tldr//lib/tldr/value/config.rb#149
  def to_full_args(exclude: T.unsafe(nil), ensure_args: T.unsafe(nil), exclude_dotfile_matches: T.unsafe(nil)); end

  # source://tldr//lib/tldr/value/config.rb#166
  def to_single_path_args(path, exclude_dotfile_matches: T.unsafe(nil)); end

  # source://tldr//lib/tldr/value/config.rb#97
  def undefault_parallel_if_seed_set(args); end

  # We needed this hook (to be called by the planner), because we can't know
  # the default prepend location until we have all the resolved test paths,
  # so we have to mutate it after the fact.
  #
  # source://tldr//lib/tldr/value/config.rb#137
  def update_after_gathering_tests!(tests); end

  def verbose; end
  def verbose=(_); end
  def warnings; end
  def warnings=(_); end
  def watch; end
  def watch=(_); end
  def yes_i_know; end
  def yes_i_know=(_); end

  private

  # If the user sets a custom base path, we need to change the working directory
  # ASAP, even before globbing to find default paths of tests. If there is
  # a way to change all of our Dir.glob calls to be relative to base_path
  # without a loss in accuracy, would love to not have to use Dir.chdir!
  #
  # source://tldr//lib/tldr/value/config.rb#242
  def change_working_directory_because_i_am_bad_and_i_should_feel_bad!(base_path); end

  # source://tldr//lib/tldr/value/config.rb#256
  def dotfile_args; end

  # source://tldr//lib/tldr/value/config.rb#250
  def merge_dotfile_args(args); end

  # source://tldr//lib/tldr/value/config.rb#232
  def most_recently_modified_test_file(tests); end

  # source://tldr//lib/tldr/value/config.rb#246
  def revert_working_directory_change_because_itll_ruin_everything!(original_base_path); end

  # source://tldr//lib/tldr/value/config.rb#220
  def stringify(key, val); end

  # source://tldr//lib/tldr/value/config.rb#177
  def to_cli_argv(options = T.unsafe(nil), exclude_dotfile_matches:); end

  class << self
    def [](*_arg0); end

    # source://tldr//lib/tldr/value/config.rb#59
    def build_defaults(cli_defaults: T.unsafe(nil)); end

    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://tldr//lib/tldr/error.rb#2
class TLDR::Error < ::StandardError; end

# source://tldr//lib/tldr/executor.rb#2
class TLDR::Executor
  # @return [Executor] a new instance of Executor
  #
  # source://tldr//lib/tldr/executor.rb#3
  def initialize; end

  # source://tldr//lib/tldr/executor.rb#10
  def execute(plan, &blk); end

  private

  # source://tldr//lib/tldr/executor.rb#26
  def run_in_parallel(tests_and_groups, &blk); end

  # source://tldr//lib/tldr/executor.rb#22
  def run_in_sequence(tests, &blk); end
end

# standard:disable Lint/InheritException
#
# source://tldr//lib/tldr/error.rb#4
class TLDR::Failure < ::Exception; end

# If it's not safe to run a set of tests in parallel, you can force them to
# run in a group together (in a single worker) with `run_these_together!` in
# your test.
#
# This method takes an array of tuples, where the first element is the class
# (or its name as a string, if the class is not yet defined in the current
# file) and the second element is the method name. If the second element is
# nil, then all the tests on the class will be run together.
#
# Examples:
#   - `run_these_together!` will run all the tests defined on the current
#     class to be run in a group
#   - `run_these_together!([[ClassA, nil], ["ClassB", :test_1], [ClassB, :test_2]])`
#    will run all the tests defined on ClassA, and test_1 and test_2 from ClassB
#
# source://tldr//lib/tldr/parallel_controls.rb#17
TLDR::GROUPED_TESTS = T.let(T.unsafe(nil), Concurrent::Array)

# source://tldr//lib/tldr/hooks.rb#2
module TLDR::Hooks
  # source://tldr//lib/tldr/hooks.rb#3
  def setup; end

  # source://tldr//lib/tldr/hooks.rb#6
  def teardown; end
end

# source://tldr//lib/tldr/value/location.rb#2
class TLDR::Location < ::Struct
  # Returns the value of attribute file
  #
  # @return [Object] the current value of file
  def file; end

  # Sets the attribute file
  #
  # @param value [Object] the value to set the attribute file to.
  # @return [Object] the newly set value
  def file=(_); end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def line; end

  # Sets the attribute line
  #
  # @param value [Object] the value to set the attribute line to.
  # @return [Object] the newly set value
  def line=(_); end

  # source://tldr//lib/tldr/value/location.rb#11
  def locator; end

  # source://tldr//lib/tldr/value/location.rb#3
  def relative; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://tldr//lib/tldr/value/config.rb#28
TLDR::MOST_RECENTLY_MODIFIED_TAG = T.let(T.unsafe(nil), String)

# source://tldr//lib/tldr/value/config.rb#27
TLDR::PATH_FLAGS = T.let(T.unsafe(nil), Array)

# source://tldr//lib/tldr/path_util.rb#2
module TLDR::PathUtil
  class << self
    # source://tldr//lib/tldr/path_util.rb#43
    def chdir_maybe(path); end

    # Because search paths to TLDR can include line numbers (e.g. a.rb:4), we
    # can't just pass everything to Dir.glob. Instead, we have to check whether
    # a user-provided search path looks like a glob, and if so, expand it
    #
    # Globby characters specified here:
    # https://ruby-doc.org/3.2.2/Dir.html#method-c-glob
    #
    # source://tldr//lib/tldr/path_util.rb#26
    def expand_globs(search_paths); end

    # source://tldr//lib/tldr/path_util.rb#3
    def expand_paths(path_strings, globs: T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://tldr//lib/tldr/path_util.rb#37
    def locations_include_test?(locations, test); end
  end
end

# source://tldr//lib/tldr/value/plan.rb#2
class TLDR::Plan < ::Struct
  # Returns the value of attribute strategy
  #
  # @return [Object] the current value of strategy
  def strategy; end

  # Sets the attribute strategy
  #
  # @param value [Object] the value to set the attribute strategy to.
  # @return [Object] the newly set value
  def strategy=(_); end

  # Returns the value of attribute tests
  #
  # @return [Object] the current value of tests
  def tests; end

  # Sets the attribute tests
  #
  # @param value [Object] the value to set the attribute tests to.
  # @return [Object] the newly set value
  def tests=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://tldr//lib/tldr/planner.rb#4
class TLDR::Planner
  # @return [Planner] a new instance of Planner
  #
  # source://tldr//lib/tldr/planner.rb#5
  def initialize; end

  # source://tldr//lib/tldr/planner.rb#9
  def plan(config); end

  private

  # source://tldr//lib/tldr/planner.rb#76
  def exclude_by_name(tests, exclude_names); end

  # source://tldr//lib/tldr/planner.rb#67
  def exclude_by_path(tests, exclude_paths); end

  # source://tldr//lib/tldr/planner.rb#130
  def expand_names_with_patterns(names); end

  # source://tldr//lib/tldr/planner.rb#88
  def filter_by_line(tests, search_locations); end

  # source://tldr//lib/tldr/planner.rb#97
  def filter_by_name(tests, names); end

  # source://tldr//lib/tldr/planner.rb#48
  def gather_tests; end

  # source://tldr//lib/tldr/planner.rb#54
  def prepend(tests, config); end

  # source://tldr//lib/tldr/planner.rb#109
  def prepend_load_paths(config); end

  # source://tldr//lib/tldr/planner.rb#115
  def require_test_helper(config); end

  # source://tldr//lib/tldr/planner.rb#124
  def require_tests(search_locations); end

  # source://tldr//lib/tldr/planner.rb#63
  def shuffle(tests, seed); end
end

# source://tldr//lib/tldr/reporters/base.rb#2
module TLDR::Reporters; end

# source://tldr//lib/tldr/reporters/base.rb#3
class TLDR::Reporters::Base
  # @return [Base] a new instance of Base
  #
  # source://tldr//lib/tldr/reporters/base.rb#4
  def initialize(config, out = T.unsafe(nil), err = T.unsafe(nil)); end

  # Called after the first test fails when --fail-fast is enabled, aborting the run
  #
  # source://tldr//lib/tldr/reporters/base.rb#32
  def after_fail_fast(planned_tests, wip_tests, test_results, last_result); end

  # Will be called after all tests have run, unless the run was aborted
  #
  # Exactly ONE of `after_suite`, `after_tldr`, or `after_fail_fast` will be called
  #
  # source://tldr//lib/tldr/reporters/base.rb#24
  def after_suite(test_results); end

  # Will be called after each test, unless the run has already been aborted
  #
  # source://tldr//lib/tldr/reporters/base.rb#18
  def after_test(test_result); end

  # Called after the suite-wide time limit expires and the run is aborted
  #
  # source://tldr//lib/tldr/reporters/base.rb#28
  def after_tldr(planned_tests, wip_tests, test_results); end

  # Will be called before any tests are run
  #
  # source://tldr//lib/tldr/reporters/base.rb#14
  def before_suite(tests); end
end

# source://tldr//lib/tldr/reporters/default.rb#3
class TLDR::Reporters::Default < ::TLDR::Reporters::Base
  # @return [Default] a new instance of Default
  #
  # source://tldr//lib/tldr/reporters/default.rb#4
  def initialize(config, out = T.unsafe(nil), err = T.unsafe(nil)); end

  # source://tldr//lib/tldr/reporters/default.rb#65
  def after_fail_fast(planned_tests, wip_tests, test_results, last_result); end

  # source://tldr//lib/tldr/reporters/default.rb#81
  def after_suite(test_results); end

  # source://tldr//lib/tldr/reporters/default.rb#21
  def after_test(result); end

  # source://tldr//lib/tldr/reporters/default.rb#35
  def after_tldr(planned_tests, wip_tests, test_results); end

  # source://tldr//lib/tldr/reporters/default.rb#9
  def before_suite(tests); end

  private

  # source://tldr//lib/tldr/reporters/default.rb#183
  def clear_screen_if_being_watched!; end

  # source://tldr//lib/tldr/reporters/default.rb#173
  def consolidate(tests, exclude: T.unsafe(nil)); end

  # source://tldr//lib/tldr/reporters/default.rb#136
  def describe(test, location = T.unsafe(nil)); end

  # source://tldr//lib/tldr/reporters/default.rb#157
  def describe_tests_that_didnt_finish(planned_tests, test_results); end

  # source://tldr//lib/tldr/reporters/default.rb#146
  def plural(count, singular, plural = T.unsafe(nil)); end

  # source://tldr//lib/tldr/reporters/default.rb#140
  def print_wip_backtrace(wip_test, indent: T.unsafe(nil)); end

  # source://tldr//lib/tldr/reporters/default.rb#112
  def summarize_failures(results); end

  # source://tldr//lib/tldr/reporters/default.rb#119
  def summarize_result(result, index); end

  # source://tldr//lib/tldr/reporters/default.rb#129
  def summarize_skips(results); end

  # source://tldr//lib/tldr/reporters/default.rb#108
  def time_diff(start, stop = T.unsafe(nil)); end

  # source://tldr//lib/tldr/reporters/default.rb#179
  def tldr_command; end

  # source://tldr//lib/tldr/reporters/default.rb#150
  def wrap_in_horizontal_rule; end
end

# source://tldr//lib/tldr.rb#27
module TLDR::Run
  class << self
    # source://tldr//lib/tldr.rb#44
    def at_exit!(config = T.unsafe(nil)); end

    # source://tldr//lib/tldr.rb#28
    def cli(argv); end

    # source://tldr//lib/tldr.rb#33
    def tests(config = T.unsafe(nil)); end
  end
end

# source://tldr//lib/tldr/runner.rb#4
class TLDR::Runner
  # @return [Runner] a new instance of Runner
  #
  # source://tldr//lib/tldr/runner.rb#5
  def initialize; end

  # source://tldr//lib/tldr/runner.rb#12
  def run(config, plan); end

  private

  # source://tldr//lib/tldr/runner.rb#103
  def exit_code(results); end

  # source://tldr//lib/tldr/runner.rb#82
  def fail_fast(reporter, plan, fast_failed_result); end

  # source://tldr//lib/tldr/runner.rb#52
  def run_test(test, config, plan, reporter); end

  # source://tldr//lib/tldr/runner.rb#98
  def time_it(start); end
end

# source://tldr//lib/tldr/error.rb#6
class TLDR::Skip < ::StandardError; end

# source://tldr//lib/tldr/skippable.rb#2
module TLDR::Skippable
  # @raise [Skip]
  #
  # source://tldr//lib/tldr/skippable.rb#3
  def skip(message = T.unsafe(nil)); end
end

# source://tldr//lib/tldr/sorbet_compatibility.rb#2
class TLDR::SorbetCompatibility
  class << self
    # source://tldr//lib/tldr/sorbet_compatibility.rb#3
    def unwrap_method(method); end
  end
end

# source://tldr//lib/tldr/strategizer.rb#2
class TLDR::Strategizer
  # Combine all discovered test methods with any methods grouped by run_these_together!
  #
  # Priorities:
  #   - Map over tests to build out groups in order to retain shuffle order
  #     (group will run in position of first test in the group)
  #   - If a test is in multiple groups, only run it once
  #
  # source://tldr//lib/tldr/strategizer.rb#13
  def strategize(all_tests, run_these_together_groups, thread_unsafe_test_groups, config); end

  private

  # Sadly duplicative with Planner.rb, necessitating the extraction of PathUtil
  # Suboptimal, but we do indeed need to do this work in two places ¯\_(ツ)_/¯
  #
  # source://tldr//lib/tldr/strategizer.rb#58
  def partition_prepend(thread_unsafe_tests, config); end

  # source://tldr//lib/tldr/strategizer.rb#50
  def partition_unsafe(tests, thread_unsafe_test_groups); end

  # source://tldr//lib/tldr/strategizer.rb#67
  def prepare_run_together_groups(run_these_together_groups, thread_safe_tests, thread_unsafe_tests); end

  # @return [Boolean]
  #
  # source://tldr//lib/tldr/strategizer.rb#46
  def run_sequentially?(all_tests, config); end
end

# source://tldr//lib/tldr/strategizer.rb#3
class TLDR::Strategizer::Strategy < ::Struct
  # Returns the value of attribute append_sequential_tests
  #
  # @return [Object] the current value of append_sequential_tests
  def append_sequential_tests; end

  # Sets the attribute append_sequential_tests
  #
  # @param value [Object] the value to set the attribute append_sequential_tests to.
  # @return [Object] the newly set value
  def append_sequential_tests=(_); end

  # Returns the value of attribute parallel?
  #
  # @return [Object] the current value of parallel?
  def parallel?; end

  # Returns the value of attribute parallel_tests_and_groups
  #
  # @return [Object] the current value of parallel_tests_and_groups
  def parallel_tests_and_groups; end

  # Sets the attribute parallel_tests_and_groups
  #
  # @param value [Object] the value to set the attribute parallel_tests_and_groups to.
  # @return [Object] the newly set value
  def parallel_tests_and_groups=(_); end

  # Returns the value of attribute prepend_sequential_tests
  #
  # @return [Object] the current value of prepend_sequential_tests
  def prepend_sequential_tests; end

  # Sets the attribute prepend_sequential_tests
  #
  # @param value [Object] the value to set the attribute prepend_sequential_tests to.
  # @return [Object] the newly set value
  def prepend_sequential_tests=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# This is a similar API to run_these_together! but its effect is more drastic
# Rather than running the provided (class, method) tuples in a group within a
# thread as part of a parallel run, it will reserve all tests specified by
# all calls to `dont_run_these_in_parallel!` to be run after all parallel tests have
# finished.
#
# This has an important implication! If your test suite is over TLDR's time
# limit, it means that these tests will never be run outside of CI unless you
# run them manually.
#
# Like `run_these_together!`, `dont_run_these_in_parallel!` takes an array of
# tuples, where the first element is the class (or its fully-qualified name as
# a string) and the second element is `nil` (matching all the class's test
# methods) or else one of the methods on the class.
#
# Examples:
#   - `dont_run_these_in_parallel!` will run all the tests defined on the current
#     class after all parallel tests have finished
#   - `dont_run_these_in_parallel!([[ClassA, nil], ["ClassB", :test_1], [ClassB, :test_2]])`
#    will run all the tests defined on ClassA, and test_1 and test_2 from ClassB
#
# source://tldr//lib/tldr/parallel_controls.rb#43
TLDR::THREAD_UNSAFE_TESTS = T.let(T.unsafe(nil), Concurrent::Array)

# source://tldr//lib/tldr/value/test.rb#2
class TLDR::Test < ::Struct
  # @return [Test] a new instance of Test
  #
  # source://tldr//lib/tldr/value/test.rb#5
  def initialize(*args); end

  # Test exact match starting line condition first to save us a potential re-parsing to look up end_line
  #
  # @return [Boolean]
  #
  # source://tldr//lib/tldr/value/test.rb#20
  def covers_line?(l); end

  # Memoizing at call time, because re-parsing isn't free and isn't usually necessary
  #
  # source://tldr//lib/tldr/value/test.rb#12
  def end_line; end

  # Returns the value of attribute file.
  #
  # source://tldr//lib/tldr/value/test.rb#3
  def file; end

  # @return [Boolean]
  #
  # source://tldr//lib/tldr/value/test.rb#24
  def group?; end

  # Returns the value of attribute line.
  #
  # source://tldr//lib/tldr/value/test.rb#3
  def line; end

  # Returns the value of attribute location.
  #
  # source://tldr//lib/tldr/value/test.rb#3
  def location; end

  # Returns the value of attribute method_name
  #
  # @return [Object] the current value of method_name
  def method_name; end

  # Sets the attribute method_name
  #
  # @param value [Object] the value to set the attribute method_name to.
  # @return [Object] the newly set value
  def method_name=(_); end

  # Returns the value of attribute test_class
  #
  # @return [Object] the current value of test_class
  def test_class; end

  # Sets the attribute test_class
  #
  # @param value [Object] the value to set the attribute test_class to.
  # @return [Object] the newly set value
  def test_class=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://tldr//lib/tldr/value/test_group.rb#2
class TLDR::TestGroup < ::Struct
  # Returns the value of attribute configuration
  #
  # @return [Object] the current value of configuration
  def configuration; end

  # Sets the attribute configuration
  #
  # @param value [Object] the value to set the attribute configuration to.
  # @return [Object] the newly set value
  def configuration=(_); end

  # @return [Boolean]
  #
  # source://tldr//lib/tldr/value/test_group.rb#18
  def group?; end

  # source://tldr//lib/tldr/value/test_group.rb#5
  def tests; end

  # Sets the attribute tests
  #
  # @param value the value to set the attribute tests to.
  #
  # source://tldr//lib/tldr/value/test_group.rb#3
  def tests=(_arg0); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://tldr//lib/tldr/value/test_result.rb#2
class TLDR::TestResult < ::Struct
  # @return [TestResult] a new instance of TestResult
  #
  # source://tldr//lib/tldr/value/test_result.rb#5
  def initialize(*args); end

  # Returns the value of attribute error
  #
  # @return [Object] the current value of error
  def error; end

  # Sets the attribute error
  #
  # @param value [Object] the value to set the attribute error to.
  # @return [Object] the newly set value
  def error=(_); end

  # @return [Boolean]
  #
  # source://tldr//lib/tldr/value/test_result.rb#31
  def error?; end

  # Returns the value of attribute error_location.
  #
  # source://tldr//lib/tldr/value/test_result.rb#3
  def error_location; end

  # @return [Boolean]
  #
  # source://tldr//lib/tldr/value/test_result.rb#15
  def failing?; end

  # @return [Boolean]
  #
  # source://tldr//lib/tldr/value/test_result.rb#27
  def failure?; end

  # @return [Boolean]
  #
  # source://tldr//lib/tldr/value/test_result.rb#11
  def passing?; end

  # source://tldr//lib/tldr/value/test_result.rb#35
  def relevant_location; end

  # Returns the value of attribute runtime
  #
  # @return [Object] the current value of runtime
  def runtime; end

  # Sets the attribute runtime
  #
  # @param value [Object] the value to set the attribute runtime to.
  # @return [Object] the newly set value
  def runtime=(_); end

  # @return [Boolean]
  #
  # source://tldr//lib/tldr/value/test_result.rb#23
  def skip?; end

  # @return [Boolean]
  #
  # source://tldr//lib/tldr/value/test_result.rb#19
  def success?; end

  # Returns the value of attribute test
  #
  # @return [Object] the current value of test
  def test; end

  # Sets the attribute test
  #
  # @param value [Object] the value to set the attribute test to.
  # @return [Object] the newly set value
  def test=(_); end

  # Returns the value of attribute type.
  #
  # source://tldr//lib/tldr/value/test_result.rb#3
  def type; end

  private

  # source://tldr//lib/tldr/value/test_result.rb#53
  def determine_error_location; end

  # source://tldr//lib/tldr/value/test_result.rb#41
  def determine_type; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://tldr//lib/tldr/version.rb#2
TLDR::VERSION = T.let(T.unsafe(nil), String)

# source://tldr//lib/tldr/value/wip_test.rb#2
class TLDR::WIPTest < ::Struct
  # Returns the value of attribute backtrace_at_exit.
  #
  # source://tldr//lib/tldr/value/wip_test.rb#3
  def backtrace_at_exit; end

  # source://tldr//lib/tldr/value/wip_test.rb#5
  def capture_backtrace_at_exit; end

  # Returns the value of attribute start_time
  #
  # @return [Object] the current value of start_time
  def start_time; end

  # Sets the attribute start_time
  #
  # @param value [Object] the value to set the attribute start_time to.
  # @return [Object] the newly set value
  def start_time=(_); end

  # Returns the value of attribute test
  #
  # @return [Object] the current value of test
  def test; end

  # Sets the attribute test
  #
  # @param value [Object] the value to set the attribute test to.
  # @return [Object] the newly set value
  def test=(_); end

  # Returns the value of attribute thread
  #
  # @return [Object] the current value of thread
  def thread; end

  # Sets the attribute thread
  #
  # @param value [Object] the value to set the attribute thread to.
  # @return [Object] the newly set value
  def thread=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://tldr//lib/tldr/watcher.rb#2
class TLDR::Watcher
  # source://tldr//lib/tldr/watcher.rb#3
  def watch(config); end

  private

  # source://tldr//lib/tldr/watcher.rb#23
  def require_fs_watch!; end
end
